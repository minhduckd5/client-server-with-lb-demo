---
# Deploy Nginx Reverse Proxy with MetalLB LoadBalancer
# This playbook deploys the nginx reverse proxy and exposes it via MetalLB

- name: Deploy Nginx Reverse Proxy with MetalLB
  hosts: k3s_control
  become: true
  gather_facts: true

  vars:
    kubeconfig_path: "/home/{{ ansible_user }}/.kube/config"
    k8s_namespace: "loadbalancer"
    k8s_manifests_dir: "{{ inventory_dir }}/../../k8s"
    # Backend Mode: 'k8s' (default) or 'host'
    # Set to 'host' to route traffic to your local machine (e.g. 192.168.1.1)
    backend_mode: "k8s" 
    host_backend_ip: "192.168.1.1"

  tasks:
    - name: Check if namespace exists
      shell: kubectl --kubeconfig={{ kubeconfig_path }} get namespace {{ k8s_namespace }}
      register: namespace_check
      # ignore_errors: true
      changed_when: false
      failed_when: namespace_check.rc != 0 and 'NotFound' not in namespace_check.stderr

    - name: Create namespace if it doesn't exist
      shell: kubectl --kubeconfig={{ kubeconfig_path }} create namespace {{ k8s_namespace }}
      when: namespace_check.rc != 0

    - name: Deploy nginx configmap (Template)
      template:
        src: templates/configmap-nginx.yaml.j2
        dest: /tmp/configmap-nginx.yaml
      
    - name: Apply nginx configmap
      shell: kubectl --kubeconfig={{ kubeconfig_path }} apply -f /tmp/configmap-nginx.yaml

    - name: Remove backend deployments (Hybrid Mode)
      shell: kubectl --kubeconfig={{ kubeconfig_path }} delete deployment -n {{ k8s_namespace }} server1 server2 server3 --ignore-not-found
      when: backend_mode == 'host'

    - name: Remove backend services (Hybrid Mode)
      shell: kubectl --kubeconfig={{ kubeconfig_path }} delete service -n {{ k8s_namespace }} server1-service server2-service server3-service --ignore-not-found
      when: backend_mode == 'host'

    - name: Copy app-config ConfigMap manifest
      copy:
        src: "{{ k8s_manifests_dir }}/configmap-app.yaml"
        dest: "/tmp/configmap-app.yaml"
      when: backend_mode == 'k8s'

    - name: Apply app-config ConfigMap
      shell: kubectl --kubeconfig={{ kubeconfig_path }} apply -f /tmp/configmap-app.yaml
      when: backend_mode == 'k8s'

    - name: Copy app-secrets Secret manifest
      copy:
        src: "{{ k8s_manifests_dir }}/secret-app.yaml"
        dest: "/tmp/secret-app.yaml"
      when: backend_mode == 'k8s'

    - name: Apply app-secrets Secret
      shell: kubectl --kubeconfig={{ kubeconfig_path }} apply -f /tmp/secret-app.yaml
      when: backend_mode == 'k8s'

    - name: Check if backend deployments are present
      shell: kubectl --kubeconfig={{ kubeconfig_path }} get deployment -n {{ k8s_namespace }} server1 server2 server3
      register: backend_deployments_check
      changed_when: false
      failed_when: false
      when: backend_mode == 'k8s'

    - name: Copy backend deployment manifests
      copy:
        src: "{{ item }}"
        dest: "/tmp/{{ item | basename }}"
      loop:
        - "{{ k8s_manifests_dir }}/deployment-server1.yaml"
        - "{{ k8s_manifests_dir }}/deployment-server2.yaml"
        - "{{ k8s_manifests_dir }}/deployment-server3.yaml"
      when: backend_mode == 'k8s'

    - name: Deploy backend deployments
      shell: |
        kubectl --kubeconfig={{ kubeconfig_path }} apply -f /tmp/deployment-server1.yaml --force
        kubectl --kubeconfig={{ kubeconfig_path }} apply -f /tmp/deployment-server2.yaml --force
        kubectl --kubeconfig={{ kubeconfig_path }} apply -f /tmp/deployment-server3.yaml --force
      when: backend_mode == 'k8s'

    - name: Restart backend deployments to pick up new images
      shell: |
        kubectl --kubeconfig={{ kubeconfig_path }} rollout restart deployment -n {{ k8s_namespace }} server1 server2 server3
      when: backend_mode == 'k8s'

    - name: Check if backend services are deployed
      shell: kubectl --kubeconfig={{ kubeconfig_path }} get svc -n {{ k8s_namespace }} server1-service server2-service server3-service
      register: backend_services_check
      changed_when: false
      failed_when: false
      when: backend_mode == 'k8s'

    - name: Debug backend services check
      debug:
        var: backend_services_check
      when: backend_mode == 'k8s'

    - name: Copy backend service manifests
      copy:
        src: "{{ item }}"
        dest: "/tmp/{{ item | basename }}"
      loop:
        - "{{ k8s_manifests_dir }}/service-server1.yaml"
        - "{{ k8s_manifests_dir }}/service-server2.yaml"
        - "{{ k8s_manifests_dir }}/service-server3.yaml"
      when: backend_mode == 'k8s'

    - name: Deploy backend services
      shell: |
        kubectl --kubeconfig={{ kubeconfig_path }} apply -f /tmp/service-server1.yaml
        kubectl --kubeconfig={{ kubeconfig_path }} apply -f /tmp/service-server2.yaml
        kubectl --kubeconfig={{ kubeconfig_path }} apply -f /tmp/service-server3.yaml
      when: backend_mode == 'k8s'

    - name: Debug pod status before wait
      shell: kubectl --kubeconfig={{ kubeconfig_path }} get pods -n {{ k8s_namespace }} -o wide
      register: pre_wait_pod_status
      when: backend_mode == 'k8s'

    - name: Display pod status before wait
      debug:
        var: pre_wait_pod_status.stdout_lines
      when: backend_mode == 'k8s'

    - name: Wait for backend *deployments* to complete rollout (max 60s each)
      shell: |
        set -e
        kubectl --kubeconfig={{ kubeconfig_path }} rollout status deployment/server1 -n {{ k8s_namespace }} --timeout=60s
        kubectl --kubeconfig={{ kubeconfig_path }} rollout status deployment/server2 -n {{ k8s_namespace }} --timeout=60s
        kubectl --kubeconfig={{ kubeconfig_path }} rollout status deployment/server3 -n {{ k8s_namespace }} --timeout=60s
      register: wait_result
      ignore_errors: true
      when: backend_mode == 'k8s'

    - name: Get backend pod status on rollout failure
      shell: kubectl --kubeconfig={{ kubeconfig_path }} get pods -n {{ k8s_namespace }} -o wide
      when: backend_mode == 'k8s' and wait_result.rc != 0
      register: backend_pods_status
      ignore_errors: true

    - name: Debug backend pod status on rollout failure
      debug:
        var: backend_pods_status.stdout_lines
      when: backend_mode == 'k8s' and wait_result.rc != 0

    - name: Get backend pod logs on rollout failure
      shell: |
        echo "---- server1 logs ----"
        kubectl --kubeconfig={{ kubeconfig_path }} logs -n {{ k8s_namespace }} -l app=server1 --tail=50 || true
        echo "---- server2 logs ----"
        kubectl --kubeconfig={{ kubeconfig_path }} logs -n {{ k8s_namespace }} -l app=server2 --tail=50 || true
        echo "---- server3 logs ----"
        kubectl --kubeconfig={{ kubeconfig_path }} logs -n {{ k8s_namespace }} -l app=server3 --tail=50 || true
      when: backend_mode == 'k8s' and wait_result.rc != 0
      register: backend_pods_logs
      ignore_errors: true

    - name: Debug backend pod logs on rollout failure
      debug:
        var: backend_pods_logs.stdout_lines
      when: backend_mode == 'k8s' and wait_result.rc != 0

    - name: Describe backend pods if rollout failed
      shell: kubectl --kubeconfig={{ kubeconfig_path }} describe pods -n {{ k8s_namespace }} -l 'app in (server1,server2,server3)'
      when: backend_mode == 'k8s' and wait_result.rc != 0

    - name: Fail if backend deployments not successfully rolled out
      fail:
        msg: "Backend deployments (server1/server2/server3) failed to roll out successfully. Check status, logs and describe output above."
      when: backend_mode == 'k8s' and wait_result.rc != 0

    - name: Ensure openssl is installed
      package:
        name: openssl
        state: present

    - name: Generate self-signed certificate for Nginx
      shell: |
        openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
        -keyout /tmp/nginx-tls.key -out /tmp/nginx-tls.crt \
        -subj "/CN=reverse-proxy/O=Ansible-Generated"

    - name: Delete existing TLS secret (if any)
      shell: kubectl --kubeconfig={{ kubeconfig_path }} delete secret nginx-reverse-proxy-tls -n {{ k8s_namespace }} --ignore-not-found

    - name: Create TLS secret
      shell: |
        kubectl --kubeconfig={{ kubeconfig_path }} create secret tls nginx-reverse-proxy-tls \
        --key /tmp/nginx-tls.key --cert /tmp/nginx-tls.crt \
        -n {{ k8s_namespace }}

    - name: Check if nginx reverse proxy deployment exists
      shell: kubectl --kubeconfig={{ kubeconfig_path }} get deployment nginx-reverse-proxy -n {{ k8s_namespace }}
      register: nginx_deployment_check
      # ignore_errors: true
      changed_when: false
      failed_when: nginx_deployment_check.rc != 0 and 'NotFound' not in nginx_deployment_check.stderr

    - name: Copy nginx reverse proxy deployment manifest
      copy:
        src: "{{ k8s_manifests_dir }}/deployment-nginx.yaml"
        dest: "/tmp/deployment-nginx.yaml"

    - name: Deploy nginx reverse proxy
      shell: kubectl --kubeconfig={{ kubeconfig_path }} apply -f /tmp/deployment-nginx.yaml --force
      register: nginx_deploy

    - name: Wait for nginx reverse proxy pods to be ready
      shell: |
        for i in {1..12}; do
          kubectl --kubeconfig={{ kubeconfig_path }} get pods -n {{ k8s_namespace }} -l app=nginx-reverse-proxy
          if kubectl --kubeconfig={{ kubeconfig_path }} wait --namespace {{ k8s_namespace }} --for=condition=ready pod -l app=nginx-reverse-proxy --timeout=5s; then
            exit 0
          fi
          echo "Waiting for nginx reverse proxy... ($i/12)"
          sleep 5
        done
        exit 1
      register: nginx_wait_result
      ignore_errors: true

    - name: Get pod status on failure
      shell: kubectl --kubeconfig={{ kubeconfig_path }} get pods -n {{ k8s_namespace }}
      when: nginx_wait_result.rc != 0
      register: pod_status
      ignore_errors: true

    - name: Display pod status
      debug:
        var: pod_status.stdout_lines
      when: nginx_wait_result.rc != 0

    - name: Get pod logs on failure
      shell: kubectl --kubeconfig={{ kubeconfig_path }} logs -n {{ k8s_namespace }} -l app=nginx-reverse-proxy --tail=50
      when: nginx_wait_result.rc != 0
      register: pod_logs
      ignore_errors: true

    - name: Display pod logs
      debug:
        var: pod_logs.stdout_lines
      when: nginx_wait_result.rc != 0

    - name: Describe pods on failure
      shell: kubectl --kubeconfig={{ kubeconfig_path }} describe pods -n {{ k8s_namespace }} -l app=nginx-reverse-proxy
      when: nginx_wait_result.rc != 0
      register: pod_describe
      ignore_errors: true

    - name: Display pod description
      debug:
        var: pod_describe.stdout_lines
      when: nginx_wait_result.rc != 0

    - name: Fail the playbook
      fail:
        msg: "Nginx reverse proxy pods failed to become ready. Check logs above for details."
      when: nginx_wait_result.rc != 0

    - name: Copy nginx reverse proxy service manifest
      copy:
        src: "{{ k8s_manifests_dir }}/service-nginx.yaml"
        dest: "/tmp/service-nginx.yaml"

    - name: Deploy nginx reverse proxy LoadBalancer service
      shell: kubectl --kubeconfig={{ kubeconfig_path }} apply -f /tmp/service-nginx.yaml
      register: nginx_service_deploy

    - name: Wait for LoadBalancer IP assignment
      shell: kubectl --kubeconfig={{ kubeconfig_path }} get svc -n {{ k8s_namespace }} nginx-service -o jsonpath='{.status.loadBalancer.ingress[0].ip}'
      register: nginx_lb_ip
      changed_when: false
      until: nginx_lb_ip.stdout != ""
      retries: 30
      delay: 5
      # ignore_errors: true

    - name: Display nginx reverse proxy LoadBalancer IP
      debug:
        msg: "Nginx Reverse Proxy LoadBalancer IP: {{ nginx_lb_ip.stdout | default('Pending assignment') }}"

    - name: Verify service endpoints
      shell: kubectl --kubeconfig={{ kubeconfig_path }} get endpoints -n {{ k8s_namespace }} nginx-service
      register: nginx_endpoints
      changed_when: false

    - name: Display service status
      debug:
        msg: "Nginx Reverse Proxy service deployed. Endpoints: {{ nginx_endpoints.stdout_lines }}"

